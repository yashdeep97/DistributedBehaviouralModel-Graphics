<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>Documentation</title>
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" type="text/css" href="fancybox/jquery.fancybox.min.css">
	<link rel="stylesheet" type="text/css" href="./code.css">
	<link rel="stylesheet" type="text/css" href="./index.css">
	<script type="text/javascript" src="highlight.pack.js"></script>
	<script type="text/javascript" src="fancybox/jquery.js"></script>
	<script type="text/javascript" src="fancybox/jquery.fancybox.min.js"></script>
	<script>hljs.initHighlightingOnLoad();</script>

</head>
<body data-spy="scroll" data-target=".sidenav" data-offset="60">

<div id="mySidenav" class="sidenav">
<!-- <h1>Contents</h1> -->
<a href="#FractalImages">Fractal Images</a>
  <a href="#Headerfiles">Header Files</a>
  <ul>
<li><a href="#boid">Boid.h</a></li>
<li><a href="#obstacle">Obstacle.h</a></li>
</ul>
  <a href="#Fractals">Fractals</a>
  <ul>
<li><a href="#Recursion">Recursion</a></li>
<li><a href="#Lsystems">L-Systems</a></li>
</ul>
  <div class="pos-bottom doneBy">
    <h3 class="doneBy">Done By:</h2>
    <ul>
      <li>Yashdeep Thorat 2015B5A70675H</li>
	  <li>Yash Gupta 2015AAPS0270H</li>
	  <li>Aditi Sharma 2015B4A70649H</li>
    </ul>
  </div>
</div>

<div id="main">
  <h1 id="FractalImages">Fractal Images:</h1>
  <a href="images/basics.png" data-fancybox="gallery" data-caption="basics">
  <img class="thumbnail" src="images/basics.png" alt="" />
  </a>
  <a href="images/Board.png" data-fancybox="gallery" data-caption="Board">
  <img class="thumbnail" src="images/Board.png" alt="" />
  </a>
  <a href="images/CircleRecursion.png" data-fancybox="gallery" data-caption="CircleRecursion">
  <img class="thumbnail" src="images/CircleRecursion.png" alt="" />
  </a>
  <a href="images/Crystal.png" data-fancybox="gallery" data-caption="Crystal">
  <img class="thumbnail" src="images/Crystal.png" alt="" />
  </a>
  <a href="images/DragonCurve.png" data-fancybox="gallery" data-caption="DragonCurve">
  <img class="thumbnail" src="images/DragonCurve.png" alt="" />
  </a>
  <a href="images/HexFractal.png" data-fancybox="gallery" data-caption="HexFractal">
  <img class="thumbnail" src="images/HexFractal.png" alt="" />
  </a>
  <a href="images/KochSnowflake.png" data-fancybox="gallery" data-caption="KochSnowflake">
  <img class="thumbnail" src="images/KochSnowflake.png" alt="" />
  </a>
  <a href="images/Pentaplexity.png" data-fancybox="gallery" data-caption="Pentaplexity">
  <img class="thumbnail" src="images/Pentaplexity.png" alt="" />
  </a>
  <a href="images/Rings.png" data-fancybox="gallery" data-caption="Rings">
  <img class="thumbnail" src="images/Rings.png" alt="" />
  </a>
  <a href="images/Shrub.png" data-fancybox="gallery" data-caption="Shrub">
  <img class="thumbnail" src="images/Shrub.png" alt="" />
  </a>
  <a href="images/SierpinskiTriangle.png" data-fancybox="gallery" data-caption="SierpinskiTriangle">
  <img class="thumbnail" src="images/SierpinskiTriangle.png" alt="" />
  </a>
  <a href="images/Tree.png" data-fancybox="gallery" data-caption="Tree">
  <img class="thumbnail" src="images/Tree.png" alt="" />
  </a>

  <h1 id="Headerfiles">Header Files</h1>
  <h2 id="boid">Boid.h</h2>
	<p>
		This header file contains a class <i>Boid</i> and each of its objects represents a boid on the screen.<br>
		It defines methods to modify the velocity of the boids by applying various rules of flocking on each boid. 
		<pre>
		  <code>
			// Define the boundaries of the Viewport
			#define XMin 0
			#define YMin 0
			#define XMax 1000
			#define YMax 1000

			class Boid
			{
				public:
					//Position, velocity of the Boid
					float posX, posY;
					float velX, velY;
					float maxForce, maxVelocity, minVelocity;
					
				public:
					// Initialize position and a random velocity for the Boid
					// Also initializes maxVelocity and minVelocity
					// @param x : x coordinate of starting point
					// @param y : y coordinate of starting point
					Boid(float x, float y);

					// Draws the boid as a triangle at its position on screen and pointing towards the direction of its velocity
					void draw();

					// Updates the position of the boid according to its velocity
					void update();

					// Applies the rule of collision avoidance on the boids, so that they do not collide with each other.
					// @param flock : a vector of all the Boid objects
					void Avoidance(vector<Boid> flock);

					// Applies the rule of collision avoidance on the boids, so that they do not collide with the obstacles.
					// @param obstacles : a vector of all the Obstacle objects
					void avoidObstacles(vector<Obstacle> obstacles);

					// Applies the rule of cohesion on the boids.
					// It applies a force on all the boids towards the centre of the flock.
					// Thus keeping the flock together.
					// @param flock : a vector of all the Boid objects
					void Cohesion(vector<Boid> flock);

					// Applies the rule of velocity matching on the boids.
					// Thus ensuring that the all the boids in the flock move in the same direction.
					// @param flock : a vector of all the Boid objects
					void Alignment(vector<Boid> flock);

					// Applies the rules of flocking on the boid.
					// @param flock : a vector of all the Boid objects
					// @param obstacles : a vector of all the Obstacle objects
					void applyRules(vector<Boid> flock, vector<Obstacle> obstacles);

					// limits the velocity of the boid so that it does not exceed the specified value.
					void limitVelocity();

					// Moves the boids to opposite side of the screen when a boid reaches the edge of the screen.
					void boundPosition();
					
					// Run the boid by applying the rules on it.
					// @param flock : a vector of all the Boid objects
					// @param obstacles : a vector of all the Obstacle objects
					void run(vector<Boid> flock, vector<Obstacle> obstacles);       
			};

		  </code>
		</pre>
	</p>
  <h2 id="obstacle">Obstacle.h</h2>
  <p>
	This header file contains a class <i>Obstacle</i> and each of its objects represents a obstacle on the screen.<br>
  	<pre>
  	  <code>
			class Obstacle
			{
				public:
					// Position of the obstacle on the screen
					float posX, posY;
			
				public:
					// Initialize position of the obstacle
					// @param x : x coordinate
					// @param y : y coordinate
					Obstacle(float x, float y);
			
					// Draw the obstacle on screen
					void draw();
					
					// Add the obstacle to screen
					void add();  
			};
  	  </code>
  	</pre>
  </p>

  <h1 id="Fractals">Fractals</h1>
  <h2 id="Recursion">Using Recursion</h2>
	<p>
		Fractals can be created using a recursive function since most fractals contain
		a repeating graphic element.<br>
		<b>CircleRecursion.cpp</b> creates a fractal using this approach.
		<pre>
			<code>
				// Recursive function for drawing fractal using circles
				// @param x : x coordinate of center of circle
				// @param y : y coordinate of center of circle
				// @param d : diameter
				void drawPattern(int x, int y, int d){
					basics.drawCircle(x,y,d/2);
					if(d>10){
						drawPattern(x+d/2, y, d/2);
						drawPattern(x-d/2, y, d/2);
						drawPattern(x, y+d/2, d/2);
						drawPattern(x, y-d/2, d/2);
					}
				}
			</code>
		</pre>
	</p>
  <h2 id="Lsystems">Using L-Systems</h2>
  <p>
	  Another way of creating fractals is using L-Systems.<br>
	  Each L-System consists of an axiom, constants, variables and production rules.<br>
	  For example, the L-System used for creating the Dragon Curve:
	  <pre>
			Variables: 	F,  H
			Constants:	 +,  -,  [,  ]
			Axiom:	 F
			Production Rules: 	F -> F+H,	 H -> F-H
	  </pre>
	  <p>Where <i>F</i> and <i>H</i> tell the turtle to move forward, '+' tells it to
	  turn right by 90<sup>0</sup> and '-' tells it to turn left by 90<sup>0</sup>.<br>
	  We start with <i>F</i> as the initial string, and for each generation, we replace
	  <i>F</i> and <i>H</i> according to the production rules. When we draw the path
	  of the turtle, we get the fractal for the given generation.</p>
	  <p>All other fractals have been created using this approach.</p>
	  <pre>
		<code>
			// Function for generating the path string for the next generation using the current path string
			// @param str : currnt path string
			void nextGeneration(string& str){
				int i = 0;
				string newstr = "";
				while(i < str.length()){
					if(str[i] == 'F'){
						newstr += "F+H";
					}else if(str[i] == 'H'){
						newstr += "F-H";
					} else {
						newstr += str[i];
					}
					i++;
				}
				str = newstr;
			}
		  </code>
	  </pre>
  </p>

	<p>
		The main function contains the code required to create a Window, set coordinate system
		and render graphics using the methods from glfw3 and graphics library.
	</p>

	<div>
		<p>
			<a target="_blank" href="https://github.com/yashdeep97/3D-Classroom-OpenGL">See full code</a>
		</p>
	</div>
</div>



</body>
</html>
